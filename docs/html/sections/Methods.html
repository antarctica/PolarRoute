

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Data Loaders &#8212; polar_route 0.0.12 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">polar_route 0.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Loaders</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-loaders">
<h1>Data Loaders<a class="headerlink" href="#data-loaders" title="Permalink to this heading">¶</a></h1>
<section id="data-sources">
<h2>Data sources<a class="headerlink" href="#data-sources" title="Permalink to this heading">¶</a></h2>
<p>The polar_route implements a variety of data-loaders to enable working with a
number of open-source datasets. Links to download some of these datasets and
there implemented data-loaders are provided in the table below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Data Type</p></th>
<th class="head"><p>Data Name</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Download</p></th>
<th class="head"><p>Data_loader</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Sea Ice Concentration</p></td>
<td><p>SIC</p></td>
<td><p>AMSR2</p></td>
<td><p><a class="reference external" href="https://seaice.uni-bremen.de/data/amsr2/asi_daygrid_swath/s6250/netcdf/">https://seaice.uni-bremen.de/data/amsr2/asi_daygrid_swath/s6250/netcdf/</a></p></td>
<td><p>load_amsr_folder</p></td>
</tr>
<tr class="row-odd"><td><p>Bathymetry</p></td>
<td><p>Elevation</p></td>
<td><p>GEBCO</p></td>
<td><p><a class="reference external" href="https://download.gebco.net/">https://download.gebco.net/</a></p></td>
<td><p>load_gebco</p></td>
</tr>
<tr class="row-even"><td><p>Currents</p></td>
<td><p>uC, vC</p></td>
<td><p>SOSE</p></td>
<td><p>…</p></td>
<td><p>load_sose_currents</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>In this section we discuss functions for loading data into the PolarRoute Mesh.
Data can be added to the Mesh using the <em>.add_data_points()</em> function of the Mesh.
This function takes a single argument, a dataframe containing datapoints in a
EPSG:4326 projection. The format in which dataframe must be given is:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Lat</p></th>
<th class="head"><p>Long</p></th>
<th class="head"><p>Time</p></th>
<th class="head"><p>value_1</p></th>
<th class="head"><p>…</p></th>
<th class="head"><p>value_n</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The data loaders provided collect or create data from heterogeneous data sources
and transform them into the correct format for use by the <em>.add_data_points()</em>
function of the Mesh.</p>
<p>Data loader functions located in the file <strong>./polar_route/data_loaders.py</strong> can
be referenced in a configuration file and called in the initialisation of the Mesh.
See the <span class="xref std std-ref">Configuration</span> section of this document for further details.</p>
<span class="target" id="module-polar_route.data_loaders"></span><p>functions for loading datasets into PolarRoute.
PolarRoute requires data as a pandas dataframe
in the following format:</p>
<p>long | lat | (time)* | value_1 | … | value_n</p>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>time is optional</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>long and lat values must be in a EPSG:4326 projection</p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_amsr">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_amsr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_amsr" title="Permalink to this definition">¶</a></dt>
<dd><p>Load AMSR2 data from a netCDF file and transform
it into a format ingestable by PolarRoute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the AMSR2 dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing AMSR2 Sea Ice Concentration</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | SIC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>amsr_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_amsr_folder">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_amsr_folder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_amsr_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Load AMSR2 data from a folder containing separate
days of AMSR2 data in netCDF files and transform
it into a format ingestable by PolarRoute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<dl class="simple">
<dt>params[‘folder’] (string): folder location of the AMSR2 dataset.</dt><dd><p>Files within the folder must be named in the form
<em>asi-AMSR2-s6250-&lt;year&gt;&lt;month&gt;&lt;day&gt;-v.5.4.nc</em></p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing AMSR2 Sea Ice Concentration</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | SIC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>amsr_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_baltic_currents">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_baltic_currents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_baltic_currents" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Baltic Sea current data from a netCDF file and
transform it into a format that is ingestable
by the pyRoutePlanner
Data source: <a class="reference external" href="https://doi.org/10.48670/moi-00013">https://doi.org/10.48670/moi-00013</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the Baltic current dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing Baltic Sea current</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | uC | vC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bc_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_baltic_sea_ice">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_baltic_sea_ice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_baltic_sea_ice" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Sea ice data for the baltic sea from a netCDF file and transform it
into a format ingestable by PolarRoute
Data Source: <a class="reference external" href="https://doi.org/10.48670/moi-00131">https://doi.org/10.48670/moi-00131</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the Baltic ice dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing Baltic Sea Ice Concentration</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | SIC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>baltic_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_baltic_thickness_density">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_baltic_thickness_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_baltic_thickness_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ice thickness and density dataframe for baltic route</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing ice thickness and density</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | thickness | density</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>thickness_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_bsose">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_bsose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_bsose" title="Permalink to this definition">¶</a></dt>
<dd><p>Load BSOSE data from a netCDF file and transform it
into a format ingestable by PolarRoute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the BSOSE dataset</p>
<dl class="simple">
<dt>params[‘units’] (string)(optional): The units SIC will be measured</dt><dd><p>in. &lt;percentage&gt; | &lt;fraction&gt;. Default is percentage</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing BSOSE Sea Ice Concentration</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | SIC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bsose_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_bsose_depth">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_bsose_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_bsose_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Load BSOSE data from a netCDF file and transform it
into a format ingestable by PolarRoute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the BSOSE dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing BSOSE bathymetry</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | elevation</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bsose_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_density">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ice density dataframe for given time and region and put it into a format ingestable by the pyRoutePlanner.
Data taken from Table 3 in: doi:10.1029/2007JC004254</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing ice density</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | density</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>density_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_era5_wind">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_era5_wind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_era5_wind" title="Permalink to this definition">¶</a></dt>
<dd><p>Load era5 wind data from a netCDF file and transform it
into a format that is ingestable by the pyRoutePlanner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the era5 dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing era5 wind</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | u10 | v10</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>era5_wind_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_gebco">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_gebco</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_gebco" title="Permalink to this definition">¶</a></dt>
<dd><p>Load GEBCO data from a netCDF file and transform it
into a format ingestable by the pyRoutePlanner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the GEBCO dataset
params[‘downsample_factors’] ([int,int]): Downsample factors in horizontal and vertical respectively.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing GEBCO elevation</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | elevation</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gebco_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_modis">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_modis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_modis" title="Permalink to this definition">¶</a></dt>
<dd><p>Load MODIS data from a netCDF file and transform it
into a format that is ingestable by the pyRoutePlanner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the MODIS dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing MODIS Sea Ice Concentration</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | SIC | cloud</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>modis_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_north_sea_currents">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_north_sea_currents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_north_sea_currents" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the Baltic current dataset</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing Baltic Sea current</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | uC | vC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bc_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_sose_currents">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_sose_currents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_sose_currents" title="Permalink to this definition">¶</a></dt>
<dd><p>Load SOSE current data from a netCDF file and#
transform it into a format that is ingestable
by the pyRoutePlanner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>params</strong> (<em>dict</em>) – <p>A dictionary containing optional parameters. This
function requires -</p>
<p>params[‘file’] (string): file location of the SOSE dataset</p>
<dl class="simple">
<dt>params[‘units’] (string)(optional)<span class="classifier">The units of measurements</span></dt><dd><p>uC and vC will be given in - &lt;km/h&gt; | &lt;m/s&gt;. Default is m/s</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing SOSE current</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | uC | vC</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sose_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="polar_route.data_loaders.load_thickness">
<span class="sig-prename descclassname"><span class="pre">polar_route.data_loaders.</span></span><span class="sig-name descname"><span class="pre">load_thickness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.data_loaders.load_thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ice thickness dataframe for given time and region and put it into a format ingestable by PolarRoute.
Data taken from Table 3 in: doi:10.1029/2007JC004254</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long_min</strong> (<em>float</em>) – The minimum longitude of the data to be retrieved</p></li>
<li><p><strong>long_max</strong> (<em>float</em>) – The maximum longitude of the data to be retrieved</p></li>
<li><p><strong>lat_min</strong> (<em>float</em>) – The minimum latitude of the data to be retrieved</p></li>
<li><p><strong>lat_max</strong> (<em>float</em>) – The maximum latitude of the data to be retrieved</p></li>
<li><p><strong>time_start</strong> (<em>string</em>) – The start time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
<li><p><strong>time_end</strong> (<em>string</em>) – The end time of the data to be retrieved,
must be given in the format “YYYY-MM-DD”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>A dataframe containing ice thickness</dt><dd><p>data. The dataframe is of the format -</p>
<p>lat | long | time | thickness</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>thickness_df (Dataframe)</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="mesh-construction">
<h1>Mesh Construction<a class="headerlink" href="#mesh-construction" title="Permalink to this heading">¶</a></h1>
<section id="id3">
<h2>Overview<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Throughout this section we will outline the use case for the Discrete Meshing of the environment. The two main classes used are <cite>Mesh</cite> and <cite>CellBox</cite>, with a Mesh being composed of a series of CellBox objects.</p>
<p>A general overview of the method can be seen below:</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="../_images/FlowDiagram_MeshGraph.png"><img alt="../_images/FlowDiagram_MeshGraph.png" src="../_images/FlowDiagram_MeshGraph.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-text">Overview figure of the Discrete Meshing from the multi-data input.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="module-polar_route.cellbox">
<span id="cellbox"></span><h2>CellBox<a class="headerlink" href="#module-polar_route.cellbox" title="Permalink to this heading">¶</a></h2>
<p>Outlined in this section we will discuss the usage of the CellBox functionality
of the PolarRoute package. In this series of class distributions we house our discrete
representation of input data. In each CellBox we determine the mean and variance of
the information governing our numerical world, this includes and is not limited to:
Ocean Currents, Sea Ice Concentration and Bathymetric depth.</p>
<p class="rubric">Example</p>
<p>An example of running this code can be executed by running the following
in a ipython/Jupyter Notebook:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">polar_route</span> <span class="kn">import</span> <span class="n">cellbox</span>
<span class="o">....</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CellBoxes are intended to be constructed by and used within a Mesh
object. The methods provided are to extract information for CellBoxes
contained within a Mesh.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.cellbox.</span></span><span class="sig-name descname"><span class="pre">CellBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting_conditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox" title="Permalink to this definition">¶</a></dt>
<dd><p>A CellBox is a collection of data-points contained within a given geo-spatial/temporal
boundary. Information about any given value of a CellBox is calculated from
the mean of all data points of that type within those bounds. CellBoxes may
be split into smaller CellBoxes and the data points within distributed
between the newly created CellBoxes so as to construct a non-uniform mesh
of CellBoxes, such as within a Mesh.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.lat">
<span class="sig-name descname"><span class="pre">lat</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.lat" title="Permalink to this definition">¶</a></dt>
<dd><p>The latitude of the top-left corner of the CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.long">
<span class="sig-name descname"><span class="pre">long</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.long" title="Permalink to this definition">¶</a></dt>
<dd><p>The longitude of the top-left corner of the CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.width">
<span class="sig-name descname"><span class="pre">width</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the CellBox, given in degrees longitude</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.height">
<span class="sig-name descname"><span class="pre">height</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the CellBox, given in degrees latitude</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All geospatial boundaries of a CellBox are given in a ‘EPSG:4326’ projection</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting_conditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – The latitude of the top-left corner of the CellBox</p></li>
<li><p><strong>long</strong> (<em>float</em>) – The longitude of the top-left corner of the CellBox</p></li>
<li><p><strong>width</strong> (<em>float</em>) – The width of the CellBox, given in degrees longitude</p></li>
<li><p><strong>height</strong> (<em>float</em>) – The height of the CellBox, given in degrees latitude</p></li>
<li><p><strong>splitting_conditions</strong> (<em>list&lt;</em><em>(</em><em>dict</em><em>)</em><em>&gt;</em>) – <p>conditions in which the CellBox
will be split into 4 smaller CellBoxes.</p>
<dl>
<dt>splitting_conditions are of the form -</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>&lt;value&gt;:{</dt><dd><p>“threshold” (float):,</p>
<p>”upperBound” (float):,</p>
<p>”lowerBound” (float)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p></li>
<li><p><strong>j_grid</strong> (<em>bool</em>) – True if the CellBox should be constructed using the
format of the original Java codebase</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.add_data_points">
<span class="sig-name descname"><span class="pre">add_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_data_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.add_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a dataframe containing datapoints to the dataframe
of datapoints within this CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_data_points</strong> (<em>Dataframe</em>) – A dataframe of data_points to be added</p></li>
<li><p><strong>-</strong> (<em>to this CellBox. new_data_points must be of the format</em>) – lat | long | (time)* | value_1 | … | value_n</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.add_splitting_condition">
<span class="sig-name descname"><span class="pre">add_splitting_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splitting_condition</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.add_splitting_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a dictionary containing a splitting condition to the
list of splitting conditions contained within this CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splitting_condition</strong> (<em>dict</em>) – a splitting condition to be added to</p></li>
<li><p><strong>-</strong> (<em>this CellBox. splitting_condition must be of the form</em>) – </p></li>
<li><p><strong>form</strong> (<em>splitting condition is of</em>) – </p></li>
<li><p><strong>{&lt;value&gt;</strong> – <p>{
‘threshold’: (float) …,
‘upperbound’: (float) …,
‘lowerbound’ (float) …:</p>
</p></li>
<li><p><strong>}}</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.contains_point">
<span class="sig-name descname"><span class="pre">contains_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.contains_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if a given lat/long coordinate is contained within this cellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – latitude of a given point</p></li>
<li><p><strong>long</strong> (<em>float</em>) – longitude of a given point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if this CellBox contains a point given by</dt><dd><p>parameters (lat, long)</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>contains_points (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_bounds">
<span class="sig-name descname"><span class="pre">get_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the bounds of this cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The geo-spatial boundaries of this CellBox.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bounds (list&lt;tuples&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_data_points">
<span class="sig-name descname"><span class="pre">get_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataframe of containing values specified in parameter ‘values’.
If values is empty, return a dataframe containing all datapoints within
the CellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>values</strong> (<em>list&lt;string&gt;</em>) – datapoints within the CellBox to be included
in the returned dataframe</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a dataframe of datapoints within the CellBox.
The dataframe is of the form -</p>
<blockquote>
<div><p>long | lat | time | value_1 | … | value_n</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>data_points (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MEAN'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the mean value of the datapoints within this cellbox
specified by the parameter ‘value’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value_name</strong> (<em>string</em>) – The value type requested</p></li>
<li><p><strong>value_type</strong> (<em>string</em>) – The output type of a value requested.
value_type may be &lt; MEAN | MIN | MAX &gt;. If none is given
a default of MIN is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The mean of all data_points of type ‘value’</dt><dd><p>within this CellBox</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>value (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getcx">
<span class="sig-name descname"><span class="pre">getcx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getcx" title="Permalink to this definition">¶</a></dt>
<dd><p>returns x-position of the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the x-position of the top-left corner of the CellBox</dt><dd><p>given in degrees longitude.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cx (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getcy">
<span class="sig-name descname"><span class="pre">getcy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getcy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y-position of the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the y-position of the top-left corner of the CellBox</dt><dd><p>given in degrees latitude.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cy (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getdcx">
<span class="sig-name descname"><span class="pre">getdcx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getdcx" title="Permalink to this definition">¶</a></dt>
<dd><p>returns x-distance from the edge to the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the x-distance from the edge of the CellBox to the</dt><dd><p>centroid of the CellBox. Given in degrees longitude</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dcx (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getdcy">
<span class="sig-name descname"><span class="pre">getdcy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getdcy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y-distance from the edge to the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the y-distance from the edge of the CellBox to the</dt><dd><p>centroid of the CellBox. Given in degrees latitude</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dxy (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.hom_condition">
<span class="sig-name descname"><span class="pre">hom_condition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.hom_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>The total homogeneity condition of this CellBox, determined by
all splitting_conditions within this CellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>The homogeneity condition of this CellBox.</dt><dd><p>hom_condition is of the form -</p>
<dl class="simple">
<dt>CLR = the proportion of datapoints within this CellBox over a given</dt><dd><p>threshold is lower than the lowerbound</p>
</dd>
<dt>HOM = the proportion of datapoints within this cellbox over a given</dt><dd><p>threshold is higher than the upperbound</p>
</dd>
</dl>
<p>MIN = the cellbox contains less than a minimum number of datapoints</p>
<dl class="simple">
<dt>HET = the proportion of datapoints within this cellbox over a given</dt><dd><p>threshold if between the upper and lower bound</p>
</dd>
</dl>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>hom_condition (string)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.should_split">
<span class="sig-name descname"><span class="pre">should_split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.should_split" title="Permalink to this definition">¶</a></dt>
<dd><p>determines if a cellbox should be split based on the homogeneity
condition of each data type contained within. The homogeneity condition
of values within this cellbox is calculated using the function
‘value_hom_condition()’</p>
<dl class="simple">
<dt>if ANY data returns ‘HOM’:</dt><dd><p>do not split</p>
</dd>
<dt>if ANY data returns ‘MIN’:</dt><dd><p>do not split</p>
</dd>
<dt>if ALL data returns ‘CLR’:</dt><dd><p>do not split</p>
</dd>
<dt>else (mixture of CLR &amp; HET):</dt><dd><p>split</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>True if the splitting_conditions of this CellBox</dt><dd><p>will result in the CellBox being split.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>should_split (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.split" title="Permalink to this definition">¶</a></dt>
<dd><p>splits the current cellbox into 4 corners, returns as a list of cellbox objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The 4 corner cellboxes generates by splitting</dt><dd><p>this current cellboxes and dividing the data_points contained between.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>split_boxes (list&lt;CellBox&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cellBox to JSON</p>
<p>The returned object is of the form -</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“geometry” (String): POLYGON(…),</p>
<p>“cx” (float): …,</p>
<p>“cy” (float): …,</p>
<p>“dcx” (float): …,</p>
<p>“dcy” (float): …,</p>
<p>“value_1” (float): …,</p>
<p>…,</p>
<p>“value_n” (float): …</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A JSON parsable dictionary representation of this CellBox</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cell_json (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.value_hom_condition">
<span class="sig-name descname"><span class="pre">value_hom_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerbound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperbound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.value_hom_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ‘CLR’, ‘HET’ or ‘HOM’ dependant on the distribution of
datapoints contained within.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>string</em>) – the name of a value a splitting condition is checked against.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold at which data points of type ‘value’ within
this CellBox are checked to be either above or below</p></li>
<li><p><strong>lowerbound</strong> (<em>float</em>) – The lowerbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’</p></li>
<li><p><strong>upperbound</strong> (<em>float</em>) – the upperbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The homogeniety condtion of this CellBox by given parameters</dt><dd><p>hom_condition is of the form -</p>
</dd>
<dt>CLR = the proportion of data points within this cellbox over a given</dt><dd><p>threshold is lower than the lowerbound</p>
</dd>
<dt>HOM = the proportion of data points within this cellbox over a given</dt><dd><p>threshold is higher than the upperbound</p>
</dd>
</dl>
<p>MIN = the cellbox contains less than a minimum number of data points</p>
<dl class="simple">
<dt>HET = the proportion of data points within this cellbox over a given</dt><dd><p>threshold if between the upper and lower bound</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>hom_condition (string)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.value_should_be_split">
<span class="sig-name descname"><span class="pre">value_should_be_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerbound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperbound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.value_should_be_split" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true or false depending on whether a splitting condition associated
with parameter ‘value’ should cause the cellbox to be split according to the
parameters ‘threshold’, ‘upperbound’ and ‘lowerbound’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>string</em>) – the name of a value a splitting condition is checked against.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold at which data_points of type ‘value’ within
this CellBox are checked to be either above or below.</p></li>
<li><p><strong>lowerbound</strong> (<em>float</em>) – The lowerbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’.</p></li>
<li><p><strong>upperbound</strong> (<em>float</em>) – the upperbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if the splitting_condition given would result in</dt><dd><p>this CellBox being split.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>should_be_split (bool)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mesh">
<h2>Mesh<a class="headerlink" href="#mesh" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.mesh.</span></span><span class="sig-name descname"><span class="pre">Mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.cellboxes">
<span class="sig-name descname"><span class="pre">cellboxes</span></span><a class="headerlink" href="#polar_route.mesh.Mesh.cellboxes" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of CellBox objects forming the Mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list&lt;(<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox">CellBox</a>)&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.neighbour_graph">
<span class="sig-name descname"><span class="pre">neighbour_graph</span></span><a class="headerlink" href="#polar_route.mesh.Mesh.neighbour_graph" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A graphical representation of the adjacency</dt><dd><p>relationship between CellBoxes in the Mesh. The neighbour_graph is
of the form</p>
</dd>
</dl>
<p>{</p>
<blockquote>
<div><p>&lt;CellBox id_1&gt;: {</p>
<blockquote>
<div><p>“1”: [id_1,…,id_n],</p>
<p>“2”: [id_1,…,id_n],</p>
<p>“3”: [id_1,…,id_n],</p>
<p>“4”: [id_1,…,id_n],</p>
<p>“-1”: [id_1,…,id_n],</p>
<p>“-2”: [id_1,…,id_n],</p>
<p>“-3”: [id_1,…,id_n],</p>
<p>“-4”: [id_1,…,id_n],</p>
</div></blockquote>
<p>},</p>
<p>…,</p>
<p>{</p>
<blockquote>
<div><p>&lt;CellBox id_n&gt;: {</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.__init__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Constructs a Mesh from a given config file.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>config (dict): config file which defines the attributes of the Mesh</dt><dd><p>to be constructed. config is of the form -</p>
<p>{</p>
<blockquote>
<div><p>“config”: {</p>
<blockquote>
<div><p>“Mesh_info”:{</p>
<blockquote>
<div><p>“Region”: {</p>
<blockquote>
<div><p>“latMin”: (real),</p>
<p>“latMax”: (real),</p>
<p>“longMin”: (real),</p>
<p>“longMax”: (real),</p>
<p>“startTime”: (string) ‘YYYY-MM-DD’,</p>
<p>“endTime”: (string) ‘YYYY-MM-DD’,</p>
<p>“cellWidth”: (real),</p>
<p>“cellHeight” (real),</p>
<p>“splitDepth” (int)</p>
</div></blockquote>
<p>},</p>
<dl>
<dt>“Data_sources”: [</dt><dd><dl>
<dt>{</dt><dd><p>“loader”: (string)</p>
<p>“params” (dict)</p>
</dd>
</dl>
<p>},</p>
<p>…,</p>
<p>{…}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>,</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><dl>
<dt>“splitting_conditions”: [</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>&lt;value&gt;: {</dt><dd><p>“threshold”: (float),</p>
<p>“upperBound”: (float),</p>
<p>“lowerBound”: (float)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>},</p>
<p>…,</p>
<p>{…}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>j_grid (bool): True if the Mesh to be constructed should be of the same</dt><dd><p>format as the original Java CellGrid, to be used for regression testing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.add_data_points">
<span class="sig-name descname"><span class="pre">add_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.add_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>takes a dataframe containing geospatial-temporal located values and assigns them to
cellboxes within this Mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_points</strong> (<em>DataFrame</em>) – <p>a dataframe of datapoints to be added to the Mesh.
data_points is of the form</p>
<p>lat | long | (time)* | value_1 | … | value_n</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_cellbox">
<span class="sig-name descname"><span class="pre">get_cellbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_cellbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the CellBox which contains a point, given by parameters lat, long</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long</strong> (<em>long</em>) – longitude of a given point</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – latitude of given point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cellbox which contains the point given my parameters
(long, lat)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cellbox (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox">CellBox</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_cellboxes">
<span class="sig-name descname"><span class="pre">get_cellboxes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_cellboxes" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of dictionaries containing information about each cellbox
in this Mesh.
all cellboxes will include id, geometry, cx, cy, dcx, dcy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>a list of CellBoxes which form the Mesh.</dt><dd><p>CellBoxes are of the form -</p>
<dl>
<dt>{</dt><dd><p>“id”: (string) …</p>
<p>”geometry”: (string) POLYGON(…),</p>
<p>”cx”: (float) …,</p>
<p>”cy”: (float) …,</p>
<p>”dcx”: (float) …,</p>
<p>”dcy”: (float) …,</p>
<p>”value_1”: (float) …,</p>
<p>…,</p>
<p>”value_n”: (float) …</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cellboxes (list&lt;dict&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_neighbour_case">
<span class="sig-name descname"><span class="pre">get_neighbour_case</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellbox_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellbox_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_neighbour_case" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two cellBoxes (cellbox_a, cellbox_b) returns a case number
representing where the two cellBoxes are touching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cellbox_a</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – starting CellBox</p></li>
<li><p><strong>cellbox_b</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – destination CellBox</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>an int representing the direction of the adjacency</dt><dd><p>between input cellbox_a and cellbox_b. The meaning of each case
is as follows -</p>
<blockquote>
<div><p>case 0 -&gt; CellBoxes are not neighbours</p>
<p>case 1 -&gt; cellbox_b is the North-East corner of cellbox_a</p>
<p>case 2 -&gt; cellbox_b is East of cellbox_a</p>
<p>case 3 -&gt; cellbox_b is the South-East corner of cellbox_a</p>
<p>case 4 -&gt; cellbox_b is South of cellbox_a</p>
<p>case -1 -&gt; cellbox_b is the South-West corner of cellbox_a</p>
<p>case -2 -&gt; cellbox_b is West of cellbox_a</p>
<p>case -3 -&gt; cellbox_b is the North-West corner of cellbox_a</p>
<p>case -4 -&gt; cellbox_b is North of cellbox_a</p>
</div></blockquote>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>case (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.split_and_replace">
<span class="sig-name descname"><span class="pre">split_and_replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellbox</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.split_and_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces a cellBox given by parameter ‘cellBox’ in this grid with
4 smaller cellBoxes representing the four corners of the given cellBox.
A neighbours map is then created for each of the 4 new cellBoxes
and the neighbours map for all surrounding cell boxes is updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cellbox</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – the CellBox within this Mesh to be split into
4 smaller CellBox objects.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.split_to_depth">
<span class="sig-name descname"><span class="pre">split_to_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">split_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.split_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>splits all cellboxes in this grid until a maximum split depth
is reached, or all cellboxes are homogeneous.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>split_depth</strong> (<em>int</em>) – The maximum split depth reached by any CellBox
within this Mesh after splitting.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this Mesh converted to string parsable as a JSON object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>a string representation of the CellGird parseable as a</dt><dd><p>JSON object. The JSON object is of the form -</p>
<dl>
<dt>{</dt><dd><p>“config”: the config used to initialize the Mesh,
“cellboxes”: a list of CellBoxes contained within the Mesh,
“neighbour_graph”: a graph representing the adjacency of CellBoxes</p>
<blockquote>
<div><p>within the Mesh</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>json (string)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="vessel-specifics">
<h1>Vessel Specifics<a class="headerlink" href="#vessel-specifics" title="Permalink to this heading">¶</a></h1>
<section id="id4">
<h2>Overview<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>All of the functionality that relates to the specific vehicle traversing our meshed environment model is contained within the vessel_performance module.
This module contains a <cite>VesselPerformance</cite> class that determines which cells in the mesh are inaccessible for that particular vessel and what its performance will be in each of the accessible cells.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="../_images/Mesh_Fuel_Speed.jpg"><img alt="../_images/Mesh_Fuel_Speed.jpg" src="../_images/Mesh_Fuel_Speed.jpg" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-text">Maps of the sea ice concentration (a), speed (b) and fuel consumption (c) across the Weddell Sea.
The latter two quantities are derived from the former.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="vessel-performance">
<h2>Vessel Performance<a class="headerlink" href="#vessel-performance" title="Permalink to this heading">¶</a></h2>
<span class="target" id="module-polar_route.vessel_performance"></span><p>The VesselPerformance class deals with all the vehicle specific features of the meshed environment model. It uses the
specific vessel parameters defined in the config to determine which cells in the mesh are inaccessible to a given
vehicle, either based on elevation or sea ice concentration, and determines vessel performance characteristics, such as
the speed and fuel consumption, based on the content of the cellboxes.</p>
<p>The input to the class is the mesh object produced by the CellGrid class in json format and it returns a modified mesh
in the same format via the VesselPerformance.to_json method.</p>
<p class="rubric">Example</p>
<p>An example of how to use this code can be executed by running the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">RoutePlanner.CellGrid</span> <span class="kn">import</span> <span class="n">CellGrid</span>
<span class="kn">from</span> <span class="nn">RoutePlanner.vessel_performance</span> <span class="kn">import</span> <span class="n">VesselPerformance</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;config.json&quot;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">cfg</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">CellGrid</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
<span class="n">mesh_json</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>

<span class="n">vp</span> <span class="o">=</span> <span class="n">VesselPerformance</span><span class="p">(</span><span class="n">mesh_json</span><span class="p">)</span>

<span class="n">vehicle_mesh</span> <span class="o">=</span> <span class="n">vp</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.vessel_performance.</span></span><span class="sig-name descname"><span class="pre">VesselPerformance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_json</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for modelling the vessel performance.
Takes a mesh as input in json format and modifies it to include vessel specifics.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.mesh">
<span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary containing all the mesh information</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.config">
<span class="sig-name descname"><span class="pre">config</span></span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.config" title="Permalink to this definition">¶</a></dt>
<dd><p>The config used to generate the input mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.mesh_df">
<span class="sig-name descname"><span class="pre">mesh_df</span></span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.mesh_df" title="Permalink to this definition">¶</a></dt>
<dd><p>The cellbox information from the mesh stored in a pandas DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.vessel_params">
<span class="sig-name descname"><span class="pre">vessel_params</span></span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.vessel_params" title="Permalink to this definition">¶</a></dt>
<dd><p>The vessel specific information contained within the config</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_json</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the VesselPerformance class from a given input mesh in json format which is then modified
according to the vessel parameters defined in the config.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh_json</strong> (<em>dict</em>) – The input mesh containing the cellboxes and neighbour graph as well as the config used</p></li>
<li><p><strong>mesh.</strong> (<em>to generate the</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.vessel_performance.VesselPerformance.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.vessel_performance.VesselPerformance.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to return the modified mesh in json format.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a dictionary representation of the modified mesh.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>j_mesh (dict)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="route-planner">
<h1>Route Planner<a class="headerlink" href="#route-planner" title="Permalink to this heading">¶</a></h1>
<section id="id5">
<h2>Overview<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>In this section we will outline the construction of the route paths using the Mesh construction corrected to include the objective functions define and generated in the earlier section.</p>
</section>
<section id="module-polar_route.route_planner">
<span id="routeplanner"></span><h2>RoutePlanner<a class="headerlink" href="#module-polar_route.route_planner" title="Permalink to this heading">¶</a></h2>
<p>This section of the codebase is used for construction of route paths using the
environmental mesh between a series of user defined waypoints</p>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.route_planner.</span></span><span class="sig-name descname"><span class="pre">RoutePlanner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">waypoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost_func=&lt;class</span> <span class="pre">'polar_route.crossing.NewtonianDistance'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner" title="Permalink to this definition">¶</a></dt>
<dd><p>—</p>
<p>RoutePlanner optimises the route paths between a series of waypoints.
The routes are constructed in a two stage process:</p>
<dl class="simple">
<dt>compute_routes: uses a mesh based Dijkstra method to determine the optimal routes</dt><dd><p>between a series of waypoint.</p>
</dd>
<dt>compute_smoothed_routes: smooths the compute_routes using information from the environmental mesh</dt><dd><p>to determine mesh independent optimal route paths</p>
</dd>
</dl>
<p>—</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner.waypoints">
<span class="sig-name descname"><span class="pre">waypoints</span></span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner.waypoints" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A dictionary of the waypoints supplied by the user in the region</dt><dd><p>of interest. The waypoints are of the form:</p>
</dd>
</dl>
<p>{</p>
<blockquote>
<div><p>“Name”:{</p>
<blockquote>
<div><p>‘0’:”Falklands”,</p>
<p>‘1’:”Rothera”,</p>
<p>…</p>
</div></blockquote>
<p>},</p>
<p>“Lat”:{</p>
<blockquote>
<div><p>‘0’:-52.6347222222,
‘1’:-75.26722,</p>
<p>…</p>
</div></blockquote>
<p>},</p>
<p>“Long”:{</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>},</p>
<p>“index”:{</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner.paths">
<span class="sig-name descname"><span class="pre">paths</span></span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner.paths" title="Permalink to this definition">¶</a></dt>
<dd><p>A GeoJSON of all paths constructed. The paths are in the form:</p>
<p>{</p>
<blockquote>
<div><p>‘types’:’FeatureCollection’,</p>
<p>“features”:{[</p>
<blockquote>
<div><p>‘type’:’feature’,</p>
<p>‘geometry’:{</p>
<blockquote>
<div><p>‘type’: ‘LineString’,</p>
<p>‘coordinates’: [[-27.21694, -75.26722],</p>
<blockquote>
<div><p>[-27.5, -75.07960297382266],</p>
<p>[-27.619238882768894, -75.0],</p>
<p>…]</p>
</div></blockquote>
</div></blockquote>
<p>},
‘properties’:{</p>
<blockquote>
<div><p>‘from’: ‘Halley’,</p>
<p>‘to’: ‘Rothera’,</p>
<p>‘traveltime’: [0.0,</p>
<blockquote>
<div><p>0.03531938671648596,</p>
<p>0.050310986633880575,</p>
<p>…],</p>
</div></blockquote>
<p>‘fuel’: [0.0,</p>
<blockquote>
<div><p>0.9648858923588642,</p>
<p>1.3745886107069096,</p>
<p>…],</p>
</div></blockquote>
<dl class="simple">
<dt>‘times’: [‘2017-01-01 00:00:00’,</dt><dd><p>‘2017-01-01 00:50:51.595036800’,
‘2017-01-01 01:12:26.869276800’,
…]</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>]}</p>
</div></blockquote>
<p>}</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geojson</p>
</dd>
</dl>
</dd></dl>

<p>—</p>
<dl class="py method">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner.compute_routes">
<span class="sig-name descname"><span class="pre">compute_routes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner.compute_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Dijkstra Paths between waypoints.
<cite>waypoints</cite> and <cite>paths</cite> are appended to output JSON</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner.compute_smoothed_routes">
<span class="sig-name descname"><span class="pre">compute_smoothed_routes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner.compute_smoothed_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the previously constructed Dijkstra paths smooth the paths to remove mesh features
<cite>paths</cite> will be updated in the output JSON</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.route_planner.RoutePlanner.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.route_planner.RoutePlanner.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputing the information in JSON format</p>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Data Loaders</a><ul>
<li><a class="reference internal" href="#data-sources">Data sources</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mesh-construction">Mesh Construction</a><ul>
<li><a class="reference internal" href="#id3">Overview</a></li>
<li><a class="reference internal" href="#module-polar_route.cellbox">CellBox</a></li>
<li><a class="reference internal" href="#mesh">Mesh</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vessel-specifics">Vessel Specifics</a><ul>
<li><a class="reference internal" href="#id4">Overview</a></li>
<li><a class="reference internal" href="#vessel-performance">Vessel Performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#route-planner">Route Planner</a><ul>
<li><a class="reference internal" href="#id5">Overview</a></li>
<li><a class="reference internal" href="#module-polar_route.route_planner">RoutePlanner</a></li>
</ul>
</li>
</ul>

  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/sections/Methods.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">polar_route 0.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Loaders</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, BAS AI Lab.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
  </body>
</html>