

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>8. Methods - Mesh Construction &#8212; polar_route 0.0.12 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. Methods - Vessel Specifics" href="Vehicle_specifics.html" />
    <link rel="prev" title="7. Examples" href="Examples.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Vehicle_specifics.html" title="9. Methods - Vessel Specifics"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Examples.html" title="7. Examples"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">polar_route 0.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Methods - Mesh Construction</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="methods-mesh-construction">
<h1><span class="section-number">8. </span>Methods - Mesh Construction<a class="headerlink" href="#methods-mesh-construction" title="Permalink to this heading">¶</a></h1>
<section id="overview">
<h2><span class="section-number">8.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>Throughout this section we will outline the use case for the Discrete Meshing of the environment. The two main classes used are <cite>Mesh</cite> and <cite>CellBox</cite>, with a Mesh being composed of a series of CellBox objects.</p>
<p>A general overview of the method can be seen below:</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="../_images/FlowDiagram_MeshGraph.png"><img alt="../_images/FlowDiagram_MeshGraph.png" src="../_images/FlowDiagram_MeshGraph.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-text">Overview figure of the Discrete Meshing from the multi-data input.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="module-polar_route.cellbox">
<span id="cellbox"></span><h2><span class="section-number">8.2. </span>CellBox<a class="headerlink" href="#module-polar_route.cellbox" title="Permalink to this heading">¶</a></h2>
<p>Outlined in this section we will discuss the usage of the CellBox functionality
of the PolarRoute package. In this series of class distributions we house our discrete
representation of input data. In each CellBox we determine the mean and variance of
the information governing our numerical world, this includes and is not limited to:
Ocean Currents, Sea Ice Concentration and Bathymetric depth.</p>
<p class="rubric">Example</p>
<p>An example of running this code can be executed by running the following
in a ipython/Jupyter Notebook:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">polar_route</span> <span class="kn">import</span> <span class="n">cellbox</span>
<span class="o">....</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CellBoxes are intended to be constructed by and used within a Mesh
object. The methods provided are to extract information for CellBoxes
contained within a Mesh.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.cellbox.</span></span><span class="sig-name descname"><span class="pre">CellBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting_conditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox" title="Permalink to this definition">¶</a></dt>
<dd><p>A CellBox is a collection of data-points contained within a given geo-spatial/temporal
boundary. Information about any given value of a CellBox is calculated from
the mean of all data points of that type within those bounds. CellBoxes may
be split into smaller CellBoxes and the data points within distributed
between the newly created CellBoxes so as to construct a non-uniform mesh
of CellBoxes, such as within a Mesh.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.lat">
<span class="sig-name descname"><span class="pre">lat</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.lat" title="Permalink to this definition">¶</a></dt>
<dd><p>The latitude of the top-left corner of the CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.long">
<span class="sig-name descname"><span class="pre">long</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.long" title="Permalink to this definition">¶</a></dt>
<dd><p>The longitude of the top-left corner of the CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.width">
<span class="sig-name descname"><span class="pre">width</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the CellBox, given in degrees longitude</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.height">
<span class="sig-name descname"><span class="pre">height</span></span><a class="headerlink" href="#polar_route.cellbox.CellBox.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the CellBox, given in degrees latitude</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All geospatial boundaries of a CellBox are given in a ‘EPSG:4326’ projection</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">splitting_conditions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – The latitude of the top-left corner of the CellBox</p></li>
<li><p><strong>long</strong> (<em>float</em>) – The longitude of the top-left corner of the CellBox</p></li>
<li><p><strong>width</strong> (<em>float</em>) – The width of the CellBox, given in degrees longitude</p></li>
<li><p><strong>height</strong> (<em>float</em>) – The height of the CellBox, given in degrees latitude</p></li>
<li><p><strong>splitting_conditions</strong> (<em>list&lt;</em><em>(</em><em>dict</em><em>)</em><em>&gt;</em>) – <p>conditions in which the CellBox
will be split into 4 smaller CellBoxes.</p>
<dl>
<dt>splitting_conditions are of the form -</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>&lt;value&gt;:{</dt><dd><p>“threshold” (float):,</p>
<p>”upperBound” (float):,</p>
<p>”lowerBound” (float)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p></li>
<li><p><strong>j_grid</strong> (<em>bool</em>) – True if the CellBox should be constructed using the
format of the original Java codebase</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.add_data_points">
<span class="sig-name descname"><span class="pre">add_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_data_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.add_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a dataframe containing datapoints to the dataframe
of datapoints within this CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_data_points</strong> (<em>Dataframe</em>) – A dataframe of data_points to be added</p></li>
<li><p><strong>-</strong> (<em>to this CellBox. new_data_points must be of the format</em>) – lat | long | (time)* | value_1 | … | value_n</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.add_splitting_condition">
<span class="sig-name descname"><span class="pre">add_splitting_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">splitting_condition</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.add_splitting_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a dictionary containing a splitting condition to the
list of splitting conditions contained within this CellBox</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>splitting_condition</strong> (<em>dict</em>) – a splitting condition to be added to</p></li>
<li><p><strong>-</strong> (<em>this CellBox. splitting_condition must be of the form</em>) – </p></li>
<li><p><strong>form</strong> (<em>splitting condition is of</em>) – </p></li>
<li><p><strong>{&lt;value&gt;</strong> – <p>{
‘threshold’: (float) …,
‘upperbound’: (float) …,
‘lowerbound’ (float) …:</p>
</p></li>
<li><p><strong>}}</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.contains_point">
<span class="sig-name descname"><span class="pre">contains_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">long</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.contains_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if a given lat/long coordinate is contained within this cellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – latitude of a given point</p></li>
<li><p><strong>long</strong> (<em>float</em>) – longitude of a given point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if this CellBox contains a point given by</dt><dd><p>parameters (lat, long)</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>contains_points (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_bounds">
<span class="sig-name descname"><span class="pre">get_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the bounds of this cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The geo-spatial boundaries of this CellBox.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bounds (list&lt;tuples&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_data_points">
<span class="sig-name descname"><span class="pre">get_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataframe of containing values specified in parameter ‘values’.
If values is empty, return a dataframe containing all datapoints within
the CellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>values</strong> (<em>list&lt;string&gt;</em>) – datapoints within the CellBox to be included
in the returned dataframe</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a dataframe of datapoints within the CellBox.
The dataframe is of the form -</p>
<blockquote>
<div><p>long | lat | time | value_1 | … | value_n</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>data_points (Dataframe)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MEAN'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the mean value of the datapoints within this cellbox
specified by the parameter ‘value’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value_name</strong> (<em>string</em>) – The value type requested</p></li>
<li><p><strong>value_type</strong> (<em>string</em>) – The output type of a value requested.
value_type may be &lt; MEAN | MIN | MAX &gt;. If none is given
a default of MIN is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The mean of all data_points of type ‘value’</dt><dd><p>within this CellBox</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>value (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getcx">
<span class="sig-name descname"><span class="pre">getcx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getcx" title="Permalink to this definition">¶</a></dt>
<dd><p>returns x-position of the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the x-position of the top-left corner of the CellBox</dt><dd><p>given in degrees longitude.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cx (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getcy">
<span class="sig-name descname"><span class="pre">getcy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getcy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y-position of the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the y-position of the top-left corner of the CellBox</dt><dd><p>given in degrees latitude.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cy (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getdcx">
<span class="sig-name descname"><span class="pre">getdcx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getdcx" title="Permalink to this definition">¶</a></dt>
<dd><p>returns x-distance from the edge to the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the x-distance from the edge of the CellBox to the</dt><dd><p>centroid of the CellBox. Given in degrees longitude</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dcx (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.getdcy">
<span class="sig-name descname"><span class="pre">getdcy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.getdcy" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y-distance from the edge to the centroid of the cellbox</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>the y-distance from the edge of the CellBox to the</dt><dd><p>centroid of the CellBox. Given in degrees latitude</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dxy (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.hom_condition">
<span class="sig-name descname"><span class="pre">hom_condition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.hom_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>The total homogeneity condition of this CellBox, determined by
all splitting_conditions within this CellBox.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>The homogeneity condition of this CellBox.</dt><dd><p>hom_condition is of the form -</p>
<dl class="simple">
<dt>CLR = the proportion of datapoints within this CellBox over a given</dt><dd><p>threshold is lower than the lowerbound</p>
</dd>
<dt>HOM = the proportion of datapoints within this cellbox over a given</dt><dd><p>threshold is higher than the upperbound</p>
</dd>
</dl>
<p>MIN = the cellbox contains less than a minimum number of datapoints</p>
<dl class="simple">
<dt>HET = the proportion of datapoints within this cellbox over a given</dt><dd><p>threshold if between the upper and lower bound</p>
</dd>
</dl>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>hom_condition (string)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.should_split">
<span class="sig-name descname"><span class="pre">should_split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.should_split" title="Permalink to this definition">¶</a></dt>
<dd><p>determines if a cellbox should be split based on the homogeneity
condition of each data type contained within. The homogeneity condition
of values within this cellbox is calculated using the function
‘value_hom_condition()’</p>
<dl class="simple">
<dt>if ANY data returns ‘HOM’:</dt><dd><p>do not split</p>
</dd>
<dt>if ANY data returns ‘MIN’:</dt><dd><p>do not split</p>
</dd>
<dt>if ALL data returns ‘CLR’:</dt><dd><p>do not split</p>
</dd>
<dt>else (mixture of CLR &amp; HET):</dt><dd><p>split</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>True if the splitting_conditions of this CellBox</dt><dd><p>will result in the CellBox being split.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>should_split (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.split" title="Permalink to this definition">¶</a></dt>
<dd><p>splits the current cellbox into 4 corners, returns as a list of cellbox objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The 4 corner cellboxes generates by splitting</dt><dd><p>this current cellboxes and dividing the data_points contained between.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>split_boxes (list&lt;CellBox&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cellBox to JSON</p>
<p>The returned object is of the form -</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“geometry” (String): POLYGON(…),</p>
<p>“cx” (float): …,</p>
<p>“cy” (float): …,</p>
<p>“dcx” (float): …,</p>
<p>“dcy” (float): …,</p>
<p>“value_1” (float): …,</p>
<p>…,</p>
<p>“value_n” (float): …</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A JSON parsable dictionary representation of this CellBox</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cell_json (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.value_hom_condition">
<span class="sig-name descname"><span class="pre">value_hom_condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerbound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperbound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.value_hom_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ‘CLR’, ‘HET’ or ‘HOM’ dependant on the distribution of
datapoints contained within.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>string</em>) – the name of a value a splitting condition is checked against.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold at which data points of type ‘value’ within
this CellBox are checked to be either above or below</p></li>
<li><p><strong>lowerbound</strong> (<em>float</em>) – The lowerbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’</p></li>
<li><p><strong>upperbound</strong> (<em>float</em>) – the upperbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>The homogeniety condtion of this CellBox by given parameters</dt><dd><p>hom_condition is of the form -</p>
</dd>
<dt>CLR = the proportion of data points within this cellbox over a given</dt><dd><p>threshold is lower than the lowerbound</p>
</dd>
<dt>HOM = the proportion of data points within this cellbox over a given</dt><dd><p>threshold is higher than the upperbound</p>
</dd>
</dl>
<p>MIN = the cellbox contains less than a minimum number of data points</p>
<dl class="simple">
<dt>HET = the proportion of data points within this cellbox over a given</dt><dd><p>threshold if between the upper and lower bound</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>hom_condition (string)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.cellbox.CellBox.value_should_be_split">
<span class="sig-name descname"><span class="pre">value_should_be_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerbound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperbound</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.cellbox.CellBox.value_should_be_split" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true or false depending on whether a splitting condition associated
with parameter ‘value’ should cause the cellbox to be split according to the
parameters ‘threshold’, ‘upperbound’ and ‘lowerbound’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>string</em>) – the name of a value a splitting condition is checked against.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – The threshold at which data_points of type ‘value’ within
this CellBox are checked to be either above or below.</p></li>
<li><p><strong>lowerbound</strong> (<em>float</em>) – The lowerbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’.</p></li>
<li><p><strong>upperbound</strong> (<em>float</em>) – the upperbound of acceptable percentage of data_points of
type value within this CellBox that are above ‘threshold’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if the splitting_condition given would result in</dt><dd><p>this CellBox being split.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>should_be_split (bool)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mesh">
<h2><span class="section-number">8.3. </span>Mesh<a class="headerlink" href="#mesh" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polar_route.mesh.</span></span><span class="sig-name descname"><span class="pre">Mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.cellboxes">
<span class="sig-name descname"><span class="pre">cellboxes</span></span><a class="headerlink" href="#polar_route.mesh.Mesh.cellboxes" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of CellBox objects forming the Mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list&lt;(<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox">CellBox</a>)&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.neighbour_graph">
<span class="sig-name descname"><span class="pre">neighbour_graph</span></span><a class="headerlink" href="#polar_route.mesh.Mesh.neighbour_graph" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>A graphical representation of the adjacency</dt><dd><p>relationship between CellBoxes in the Mesh. The neighbour_graph is
of the form</p>
</dd>
</dl>
<p>{</p>
<blockquote>
<div><p>&lt;CellBox id_1&gt;: {</p>
<blockquote>
<div><p>“1”: [id_1,…,id_n],</p>
<p>“2”: [id_1,…,id_n],</p>
<p>“3”: [id_1,…,id_n],</p>
<p>“4”: [id_1,…,id_n],</p>
<p>“-1”: [id_1,…,id_n],</p>
<p>“-2”: [id_1,…,id_n],</p>
<p>“-3”: [id_1,…,id_n],</p>
<p>“-4”: [id_1,…,id_n],</p>
</div></blockquote>
<p>},</p>
<p>…,</p>
<p>{</p>
<blockquote>
<div><p>&lt;CellBox id_n&gt;: {</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.__init__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Constructs a Mesh from a given config file.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>config (dict): config file which defines the attributes of the Mesh</dt><dd><p>to be constructed. config is of the form -</p>
<p>{</p>
<blockquote>
<div><p>“config”: {</p>
<blockquote>
<div><p>“Mesh_info”:{</p>
<blockquote>
<div><p>“Region”: {</p>
<blockquote>
<div><p>“latMin”: (real),</p>
<p>“latMax”: (real),</p>
<p>“longMin”: (real),</p>
<p>“longMax”: (real),</p>
<p>“startTime”: (string) ‘YYYY-MM-DD’,</p>
<p>“endTime”: (string) ‘YYYY-MM-DD’,</p>
<p>“cellWidth”: (real),</p>
<p>“cellHeight” (real),</p>
<p>“splitDepth” (int)</p>
</div></blockquote>
<p>},</p>
<dl>
<dt>“Data_sources”: [</dt><dd><dl>
<dt>{</dt><dd><p>“loader”: (string)</p>
<p>“params” (dict)</p>
</dd>
</dl>
<p>},</p>
<p>…,</p>
<p>{…}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>,</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><dl>
<dt>“splitting_conditions”: [</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>&lt;value&gt;: {</dt><dd><p>“threshold”: (float),</p>
<p>“upperBound”: (float),</p>
<p>“lowerBound”: (float)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>},</p>
<p>…,</p>
<p>{…}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>j_grid (bool): True if the Mesh to be constructed should be of the same</dt><dd><p>format as the original Java CellGrid, to be used for regression testing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.add_data_points">
<span class="sig-name descname"><span class="pre">add_data_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_points</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.add_data_points" title="Permalink to this definition">¶</a></dt>
<dd><p>takes a dataframe containing geospatial-temporal located values and assigns them to
cellboxes within this Mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data_points</strong> (<em>DataFrame</em>) – <p>a dataframe of datapoints to be added to the Mesh.
data_points is of the form</p>
<p>lat | long | (time)* | value_1 | … | value_n</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_cellbox">
<span class="sig-name descname"><span class="pre">get_cellbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">long</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_cellbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the CellBox which contains a point, given by parameters lat, long</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>long</strong> (<em>long</em>) – longitude of a given point</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – latitude of given point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cellbox which contains the point given my parameters
(long, lat)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cellbox (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox">CellBox</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_cellboxes">
<span class="sig-name descname"><span class="pre">get_cellboxes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_cellboxes" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of dictionaries containing information about each cellbox
in this Mesh.
all cellboxes will include id, geometry, cx, cy, dcx, dcy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>a list of CellBoxes which form the Mesh.</dt><dd><p>CellBoxes are of the form -</p>
<dl>
<dt>{</dt><dd><p>“id”: (string) …</p>
<p>”geometry”: (string) POLYGON(…),</p>
<p>”cx”: (float) …,</p>
<p>”cy”: (float) …,</p>
<p>”dcx”: (float) …,</p>
<p>”dcy”: (float) …,</p>
<p>”value_1”: (float) …,</p>
<p>…,</p>
<p>”value_n”: (float) …</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>cellboxes (list&lt;dict&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.get_neighbour_case">
<span class="sig-name descname"><span class="pre">get_neighbour_case</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellbox_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellbox_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.get_neighbour_case" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two cellBoxes (cellbox_a, cellbox_b) returns a case number
representing where the two cellBoxes are touching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cellbox_a</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – starting CellBox</p></li>
<li><p><strong>cellbox_b</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – destination CellBox</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>an int representing the direction of the adjacency</dt><dd><p>between input cellbox_a and cellbox_b. The meaning of each case
is as follows -</p>
<blockquote>
<div><p>case 0 -&gt; CellBoxes are not neighbours</p>
<p>case 1 -&gt; cellbox_b is the North-East corner of cellbox_a</p>
<p>case 2 -&gt; cellbox_b is East of cellbox_a</p>
<p>case 3 -&gt; cellbox_b is the South-East corner of cellbox_a</p>
<p>case 4 -&gt; cellbox_b is South of cellbox_a</p>
<p>case -1 -&gt; cellbox_b is the South-West corner of cellbox_a</p>
<p>case -2 -&gt; cellbox_b is West of cellbox_a</p>
<p>case -3 -&gt; cellbox_b is the North-West corner of cellbox_a</p>
<p>case -4 -&gt; cellbox_b is North of cellbox_a</p>
</div></blockquote>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>case (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.split_and_replace">
<span class="sig-name descname"><span class="pre">split_and_replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cellbox</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.split_and_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces a cellBox given by parameter ‘cellBox’ in this grid with
4 smaller cellBoxes representing the four corners of the given cellBox.
A neighbours map is then created for each of the 4 new cellBoxes
and the neighbours map for all surrounding cell boxes is updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cellbox</strong> (<a class="reference internal" href="#polar_route.cellbox.CellBox" title="polar_route.cellbox.CellBox"><em>CellBox</em></a>) – the CellBox within this Mesh to be split into
4 smaller CellBox objects.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.split_to_depth">
<span class="sig-name descname"><span class="pre">split_to_depth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">split_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.split_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>splits all cellboxes in this grid until a maximum split depth
is reached, or all cellboxes are homogeneous.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>split_depth</strong> (<em>int</em>) – The maximum split depth reached by any CellBox
within this Mesh after splitting.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polar_route.mesh.Mesh.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#polar_route.mesh.Mesh.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this Mesh converted to string parsable as a JSON object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>a string representation of the CellGird parseable as a</dt><dd><p>JSON object. The JSON object is of the form -</p>
<dl>
<dt>{</dt><dd><p>“config”: the config used to initialize the Mesh,
“cellboxes”: a list of CellBoxes contained within the Mesh,
“neighbour_graph”: a graph representing the adjacency of CellBoxes</p>
<blockquote>
<div><p>within the Mesh</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>json (string)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">8. Methods - Mesh Construction</a><ul>
<li><a class="reference internal" href="#overview">8.1. Overview</a></li>
<li><a class="reference internal" href="#module-polar_route.cellbox">8.2. CellBox</a></li>
<li><a class="reference internal" href="#mesh">8.3. Mesh</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Examples.html"
                          title="previous chapter"><span class="section-number">7. </span>Examples</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="Vehicle_specifics.html"
                          title="next chapter"><span class="section-number">9. </span>Methods - Vessel Specifics</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/sections/Discrete_meshing.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Vehicle_specifics.html" title="9. Methods - Vessel Specifics"
             >next</a> |</li>
        <li class="right" >
          <a href="Examples.html" title="7. Examples"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">polar_route 0.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Methods - Mesh Construction</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, BAS AI Lab.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
  </body>
</html>